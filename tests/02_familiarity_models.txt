
#############################################################################
####          Familiarity analysis - build models for analysis           ####
#############################################################################





1. Set working directory, import libraries and table ------------------------------
# ---------------------------------------------------------------------------------
# bhvr directory
#setwd("C:/Users/mffranco/UQAM/Montiglio, Pierre-Olivier - Maxime Fraser Franco/MFraserFranco(2019-06-11)/Behaviour_projects/familiarity_analysis/outputs")

library(data.table)
library(tidyr)
library(lme4) # mixed modeling package
library(MuMIn) # for r square calculations
library(DHARMa) # for model diagnostics
library(ggplot2)
library(ggcorrplot)

# When the script has been run once, just import by loading -----------
# ---------------------------------------------------------------------
# data <- fread("01_complete_table.csv") # (just needed this table once)
# load("02_model_datarole.rda") # New dataset after running this script
load("02_model_data_subrole.rda")

# Import models ------------------
load("02_surv.model.realms.A.rda")
load("02_surv.model.realms.B.rda")
load("02_surv.model.realms.C.rda")
load("02_surv.model.realms.D.rda")
# ------------------
load("02_kill.model.realms.A.rda")
load("02_kill.model.realms.B.rda")
load("02_kill.model.realms.C.rda")
load("02_kill.model.realms.D.rda")
# --------------------------------

# Import tables ------------------
load("02_surv.familiarity-ranef.rda")
load("02_killer.familiarity-ranef.rda")
load("02_familiarity.r2.rda")
# ---------------------------------------------------------------------

# Quick checkups (I might need to delete a lot of matches) (DONE ONCE) :
# Check the distribution of bloodpoints
# hist(data$bloodpoints, breaks = 100)
# range(data$bloodpoints) # there are matches with BP values of 1

# There are bloodpoints above 32 000 *delete them
# done once and saved
# data <- data[!bloodpoints > 32000]
# data <- data[!outcome == "Killer Disconnected"]
# save(data, file = "02_model_datarole.rda")
# -------------------


# Model should be runned on a subsample of 2500 players if too slow (DONE ONCE)
# mirrors_id <- unique(data$mirrors_id)
# set.seed(20200218)
# mirrors_id <- sample(mirrors_id, size = 2500, replace = FALSE)
# mirrors_id <- as.data.table(mirrors_id)

# Re merge with complete_table to only have 2500 players
# data1 <- merge(mirrors_id, data, by = "mirrors_id")

# save(data1, file = "02_model_data_subrole.rda")





# 2. Create experience variables (DONE ONCE) ----------------------------------------
# ---------------------------------------------------------------------------------
# Arrange the realms variable to nest the maps in them
data1[, realms := substr(map_name, start = 1, stop = 3)]
data1$realms <- as.factor(data1$realms)


# Order timestamps
# library(lubridate)
# data1[, timestamp := ymd_hms(timestamp)]
# setorder(data1, timestamp, mirrors_id)


# Vector for cumsum calculation must start at 0 (first match)
#for.cumsum <- data1[, .SD[which.min(timestamp)], by = mirrors_id]
#for.cumsum[, for_cumsum := 0]
#data1 <- merge(for.cumsum[,c(2:3,50)], data1, all.y=T, by =c("timestamp", "match_id"))
#for (col in "for_cumsum.x") data1[is.na(get(col)), (col) := 1] # replace all NAs with 1


# Total cumulative sum of matches
# ----------------
# data1[, xp.total := cumsum(for_cumsum), by = mirrors_id]
# ----------------


# Cumulative sum of matches by role and by map 
# ----------------
# Total experience in the focal role
# data1[, xp.focal.role := cumsum(for_cumsum), by = .(mirrors_id, role)]

# Experience in the focal map or realm
# data1[, xp.focal.map := cumsum(for_cumsum), by = .(mirrors_id, map_name)]
# data1[, xp.focal.realm := cumsum(for_cumsum), by = .(mirrors_id, realms)]

# Experience in the focal map for each role, variables no.1 and no.2 for Julien
# data1[, xp.focal.rolemap := cumsum(for_cumsum), by = .(mirrors_id, role, map_name)]
# data1[, xp.focal.rolerealm := cumsum(for_cumsum), by = .(mirrors_id, role, realms)]

# Prior experience in the other role
# data1[, priorxp.other.role := xp.total - xp.focal.role]

# Prior experience in other maps in the focal role, variables no.3 and no.4 for Julien
# data1[, priorxp.other.maps := xp.focal.role - xp.focal.rolemap]
# data1[, priorxp.other.realms := xp.focal.role - xp.focal.rolerealm]
# ----------------

# save table
# save(data1, file = "02_model_data_subrole.rda")





# 3. Inspect correlation between predictors -----------------------------------------
# -----------------------------------------------------------------------------------
# Correlation among variables (visualize as a correlation matrix or as a correlation plot)
cor.matrix <- cor(data1[, c(51:59)]) # Pearson r linear correlation
cor.matrix <- round(cor.matrix, 2) # Rounds the coefficients to 2 decimal points

p.values.cor.matrix <- cor_pmat(cor.matrix)
full_cor_plot <- ggcorrplot(cor.matrix, hc.order = TRUE, type = "lower", lab = TRUE, digits = 2)

# All variables are highly correlated except the ones with the prior role experience





# 4. Arrange character variables as factor ----------------------------------------
# ---------------------------------------------------------------------------------
# Character variables to factor variables
char_as_factor <- names(data1)[sapply(data1, is.character)] # extract columns that are characters
data1[, (char_as_factor) := lapply(.SD, as.factor), .SDcols = char_as_factor] # columns as factors


# Arrange rank as an ordinal factor
data1[, rank := factor(rank, order = TRUE, levels = c(20, 19, 18, 17, 16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1))]





# 5. Create variables specific to models and decompose into survivor and killer tables ----
# -----------------------------------------------------------------------------------------
# Model A
# Create the variables for model A (total.xp.A) (THIS IS NOW IN MODEL D**** (D WAS A BEFORE, I CHANGED THAT))
data1[, total.xp.modelA.maps := xp.total - xp.focal.rolemap]
data1[, total.xp.modelA.realms := xp.total - xp.focal.rolerealm]

# Model B (THIS IN MODEL C**** (C WAS B BEFORE, I CHANGED THAT))
# Create the variables for model B (total.xp.B)
data1[, total.xp.modelB.maps := xp.total - xp.focal.map]
data1[, total.xp.modelB.realms := xp.total - xp.focal.realm]

# Create tables for survivors and killers
surv.dat <- data1[role == "VE_Camper"]
killer.dat <- data1[role == "VE_Slasher"]


# Normalize (Z-scores) main variables using scale() function
surv.dat[, c("Zchase.count", "Znum.chases", "Zxp.total", "Zxp.focal.role", "Zxp.focal.map", "Zxp.focal.realm", "Zxp.focal.rolemap", "Zxp.focal.rolerealm", "Zpriorxp.other.role", "Zpriorxp.other.maps", "Zpriorxp.other.realms") :=
            lapply(.SD, scale), .SDcols = c(34, 38, 51:59)]

killer.dat[, c("Zchase.count", "Znum.chases", "Zxp.total", "Zxp.focal.role", "Zxp.focal.map", "Zxp.focal.realm", "Zxp.focal.rolemap", "Zxp.focal.rolerealm", "Zpriorxp.other.role", "Zpriorxp.other.maps", "Zpriorxp.other.realms") :=
            lapply(.SD, scale), .SDcols = c(34, 38, 51:59)]

surv.dat[, c("Ztotal.xp.modelA.maps", "Ztotal.xp.modelA.realms", "Ztotal.xp.modelB.maps", "Ztotal.xp.modelB.realms") :=
            lapply(.SD, scale), .SDcols = c(60:63)]

killer.dat[, c("Ztotal.xp.modelA.maps", "Ztotal.xp.modelA.realms", "Ztotal.xp.modelB.maps", "Ztotal.xp.modelB.realms") :=
            lapply(.SD, scale), .SDcols = c(60:63)]




# Add an observation-level random effect (OLRE) (controls for overdispersion in the models)
surv.dat$obs <- 1:nrow(surv.dat)
killer.dat$obs <- 1:nrow(killer.dat)





# 6. Define models ------------------------------------------------------------------
# -----------------------------------------------------------------------------------

# Overdispersion function by B. Bolker from https://bbolker.github.io/mixedmodels-misc/glmmFAQ.html#overdispersion)
# Use it to test if model is overdispersed (almost always happens with DBD data)
overdisp_fun <- function(model) {
   rdf <- df.residual(model)
   rp <- residuals(model, type = "pearson")
   Pearson.chisq <- sum(rp^2)
   prat <- Pearson.chisq/rdf
   pval <- pchisq(Pearson.chisq, df = rdf, lower.tail = FALSE)
   c(chisq = Pearson.chisq, ratio = prat, rdf = rdf, p = pval)
}



# Survivor models

# Model A - TOTAL XP
# -------
#system.time(surv.model.realms.A <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.total + 
#I(Zxp.total^2) +
#(1 | realms) +
#(1 + Zxp.total | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = surv.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(surv.model.realms.A, file = "02_surv.model.realms.A.rda")
# ------------------


# Model B - XP FOCAL ROLE
# -------
# Quadratic effect of total not significant so I took it out
#system.time(surv.model.realms.B <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.role + 
#I(Zxp.focal.role^2) +
#Zpriorxp.other.role +
#(1 | realms) +
#(1 + Zxp.focal.role | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = surv.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(surv.model.realms.B, file = "02_surv.model.realms.B.rda")
# ------------------


# Model C - XP FOCAL REALM
# -------
# Quadratic effect not significant so I dont use it
#system.time(surv.model.realms.C <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.realm + 
#Ztotal.xp.modelB.realms +
#I(Ztotal.xp.modelB.realms^2) +
#(1 | realms) +
#(1 + Zxp.focal.realm | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = surv.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(surv.model.realms.C, file = "02_surv.model.realms.C.rda")
# ------------------


# Model D - XP FOCAL REALM AND ROLE
# -------
# Quadratic effect non significant nor important
#system.time(surv.model.realms.D <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.rolerealm + 
#Ztotal.xp.modelA.realms +
#I(Ztotal.xp.modelA.realms^2) +
#(1 | realms) +
#(1 + Zxp.focal.rolerealm | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = surv.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(surv.model.realms.D, file = "02_surv.model.realms.D.rda")
# --------------------------------------------------------



# Killer models

# Model A - TOTAL XP
# -------
# Run the model without the values with 10sd above the mean (there are 37 matches with wierd patterns)
#system.time(kill.model.realms.A <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.total + 
#I(Zxp.total^2) +
#(1 + Zxp.total | realms) +
#(1 + Zxp.total | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = killer.dat[Zxp.total < 7.5],
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(kill.model.realms.A, file = "02_kill.model.realms.A.rda")
# ------------------


# Model B - XP FOCAL ROLE
# -------
#system.time(kill.model.realms.B <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.role + 
#I(Zxp.focal.role^2) +
#Zpriorxp.other.role +
#I(Zpriorxp.other.role^2) +
#(1 + Zxp.focal.role | realms) +
#(1 + Zxp.focal.role | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = killer.dat[Zpriorxp.other.role < 8],
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(kill.model.realms.B, file = "02_kill.model.realms.B.rda")
# ------------------


# Model C - XP FOCAL REALM
# -------
# linear effect not significant, remove quadratic effect
#system.time(kill.model.realms.C <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.realm + 
#Ztotal.xp.modelB.realms +
#I(Ztotal.xp.modelB.realms^2) +
#(1 + Zxp.focal.realm | realms) +
#(1 + Zxp.focal.realm | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = killer.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(kill.model.realms.C, file = "02_kill.model.realms.C.rda")
# ------------------


# Model D - XP FOCAL REALM AND ROLE
# -------
#system.time(kill.model.realms.D <- glmer(cbind(bloodpoints, 32000-bloodpoints) ~
#rank +
#Zxp.focal.rolerealm + 
#I(Zxp.focal.rolerealm^2) +
#Ztotal.xp.modelA.realms +
#I(Ztotal.xp.modelA.realms^2) +
#(1 + Zxp.focal.rolerealm | realms) +
#(1 + Zxp.focal.rolerealm | mirrors_id) +
#(1 | platform) +
#(1 | obs),
#data = killer.dat,
#family = binomial, nAGQ = 0,
#control = glmerControl(optimizer = "nloptwrap", nAGQ0initStep = TRUE, optCtrl=list(maxfun = 2e9))))
#save(kill.model.realms.D, file = "02_kill.model.realms.D.rda")



# Random effect tables
# -------------------------------------------------------------
# Survivors :
realmsA <- as.data.table(VarCorr(surv.model.realms.A), comp = "Variance")
realmsB <- as.data.table(VarCorr(surv.model.realms.B), comp = "Variance")
realmsC <- as.data.table(VarCorr(surv.model.realms.C), comp = "Variance")
realmsD <- as.data.table(VarCorr(surv.model.realms.D), comp = "Variance")

realmsA <- cbind(model = "realmsA", realmsA)
realmsB <- cbind(model = "realmsB", realmsB)
realmsC <- cbind(model = "realmsC", realmsC)
realmsD <- cbind(model = "realmsD", realmsD)

ranefs.surv <- rbind(realmsA, realmsB, realmsC, realmsD)

# Change variable names for clarification
setnames(ranefs.surv, "grp", "Random.factor")
setnames(ranefs.surv, "var1", "Coefficient")
setnames(ranefs.surv, "vcov", "Variance")
setnames(ranefs.surv, "sdcor", "Std.dev")

# Create the proportion variable
ranefs.surv <- ranefs.surv[!c(4, 10, 16, 22)]
ranefs.surv[, "Proportion.of.variance" := Variance / (sum(ranefs.surv[,Variance])), 
                  by = .(model, Random.factor)]
ranefs.surv[,c(5:7)] <- round(ranefs.surv[,c(5:7)], digits = 4)
#save(ranefs.surv, file = "02_surv.familiarity-ranef.rda")


# Killers : Create the random effects table
realmsA <- as.data.table(VarCorr(kill.model.realms.A), comp = "Variance")
realmsB <- as.data.table(VarCorr(kill.model.realms.B), comp = "Variance")
realmsC <- as.data.table(VarCorr(kill.model.realms.C), comp = "Variance")
realmsD <- as.data.table(VarCorr(kill.model.realms.D), comp = "Variance")

realmsA <- cbind(model = "realmsA", realmsA)
realmsB <- cbind(model = "realmsB", realmsB)
realmsC <- cbind(model = "realmsC", realmsC)
realmsD <- cbind(model = "realmsD", realmsD)

ranefs.kill <- rbind(realmsA, realmsB, realmsC, realmsD)

# Change variable names for clarification
setnames(ranefs.kill, "grp", "Random.factor")
setnames(ranefs.kill, "var1", "Coefficient")
setnames(ranefs.kill, "vcov", "Variance")
setnames(ranefs.kill, "sdcor", "Std.dev")

# Create the proportion variable
ranefs.kill <- ranefs.kill[!c(4, 7, 12, 15, 20, 23, 28, 31)]
ranefs.kill[, "Proportion.of.variance" := Variance / (sum(ranefs.kill[,Variance])), 
                  by = .(model, Random.factor)]
ranefs.kill[,c(5:7)] <- round(ranefs.kill[,c(5:7)], digits = 4)
# save(ranefs.kill, file = "02_killer.familiarity-ranef.rda")
# -------------------------------------------------------------





# 7. Check model diagnostics ------------------------------------------------------
# ---------------------------------------------------------------------------------
# SHould also check a qqplot of conditional means (from random effects) (sjPlot package)

# Check residual structure using DHARMa package (simulation)
#simulationOutput <- simulateResiduals(fittedModel = surv.model.realms.A, n = 250)
#save(simulationOutput, file = "02_survA_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = surv.model.realms.B, n = 250)
#save(simulationOutput, file = "02_survB_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = surv.model.realms.C, n = 250)
#save(simulationOutput, file = "02_survC_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = surv.model.realms.D, n = 250)
#save(simulationOutput, file = "02_survD_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = kill.model.realms.A, n = 250)
#save(simulationOutput, file = "02_killA_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = kill.model.realms.B, n = 250)
#save(simulationOutput, file = "02_killB_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = kill.model.realms.C, n = 250)
#save(simulationOutput, file = "02_killC_sim_residuals.rda")
#simulationOutput <- simulateResiduals(fittedModel = kill.model.realms.D, n = 250)
#save(simulationOutput, file = "02_killD_sim_residuals.rda")

#plot(simulationOutput)

#testDispersion(simulationOutput)
#testUniformity(simulationOutput)

# Here are some examples but you can plot whatever x variable with the residuals of your model
# you can also plot your random effects
# Be sure to plot the right coefficient with the right model's simulated residuals
#plotResiduals(data1$Zxp.focal.rolerealm,  simulationOutput$scaledResiduals)
#plotResiduals(data1$Zxp.focalrole,  simulationOutput$scaledResiduals)
#plotResiduals(data1$Zxp.total,  simulationOutput$scaledResiduals)
#plotResiduals(data1$Zxp.focal.realm,  simulationOutput$scaledResiduals)
#plotResiduals(data1$platform,  simulationOutput$scaledResiduals)





# 6. Assess model fit ------------------------------------------------------------
# --------------------------------------------------------------------------------
# Extract marginal and conditionnal R-squared values using Barton's package function from Nakagawa, and Johnson's papers
#models <- list(surv.model.realms.A, surv.model.realms.B, surv.model.realms.C, surv.model.realms.D, kill.model.realms.A, kill.model.realms.B, kill.model.realms.C, kill.model.realms.D)

# Create a function that will apply r.squaredGLMM to the model list
#R2 <- function (models) {r.squaredGLMM(models)}

# Compute the function to the list and save in an object
#r.squared <- sapply(models, R2)

# Only keep 1st and 3rd line corresponding to theoretical R2 values (1st line = marginal, 3rd line = conditional)
r.squared <- as.data.table(r.squared)
r.squared <- r.squared[! c(2, 4)]
r.squared[, type := c("marginal", "conditional")]
setcolorder(r.squared, c(9, 1:8))

# Save table in long format
r.squared <- gather(r.squared, model, R2, c(2:9))
setcolorder(r.squared, c(2, 1, 3))
r.squared <- as.data.table(r.squared)
models <- c("surv.model.realms.A", "surv.model.realms.A",
"surv.model.realms.B", "surv.model.realms.B",
"surv.model.realms.C", "surv.model.realms.C",
"surv.model.realms.D", "surv.model.realms.D",
"kill.model.realms.A", "kill.model.realms.A",
"kill.model.realms.B","kill.model.realms.B", 
"kill.model.realms.C", "kill.model.realms.C",
"kill.model.realms.D","kill.model.realms.D")
r.squared[, model := models]

# Save in outputs folder
# save(r.squared, file = "02_familiarity.r2.rda")
load("02_familiarity.r2.rda")
# --------------------------------------------------------------------------------------